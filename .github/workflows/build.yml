name: ImmortalWRT Package Builder

on:
  workflow_dispatch:
    inputs:
      clean_build:
        description: '强制清理并重新编译所有包'
        required: false
        default: false
        type: boolean
      skip_commit_check:
        description: '跳过提交检查，强制重新编译'
        required: false
        default: false
        type: boolean
      toolchain_version:
        description: 'ImmortalWRT Toolchain 版本'
        required: false
        default: '21.02'
        type: choice
        options:
          - '19.07'
          - '21.02'
          - '22.03'
          - 'snapshot'

env:
  OUTPUTS_BRANCH: 'outputs'
  COMMIT_LOG_DIR: '.commit_history'
  BUILD_STATUS_DIR: '.build_status'
  ARTIFACT_DIR: 'artifacts'

jobs:
  setup-and-build:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Checkout outputs branch
        uses: actions/checkout@v4
        with:
          ref: outputs
          path: outputs-branch

      - name: Initialize directories
        run: |
          mkdir -p ${{ env.COMMIT_LOG_DIR }}
          mkdir -p ${{ env.BUILD_STATUS_DIR }}
          mkdir -p ${{ env.ARTIFACT_DIR }}
          
          # 复制现有的提交记录
          if [ -d "outputs-branch/${{ env.COMMIT_LOG_DIR }}" ]; then
            cp -r outputs-branch/${{ env.COMMIT_LOG_DIR }}/* ${{ env.COMMIT_LOG_DIR }}/ 2>/dev/null || true
          fi

      - name: Setup build environment
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential ccache ecj fastjar file g++ gawk gettext \
            git java-propose-classpath libelf-dev libncurses5-dev \
            libncursesw5-dev libssl-dev python3 python3-distutils \
            python3-setuptools rsync subversion swig time unzip wget \
            xsltproc zlib1g-dev mercurial subversion

      - name: Setup ImmortalWRT toolchain
        run: |
          chmod +x scripts/setup-toolchain.sh
          ./scripts/setup-toolchain.sh ${{ github.event.inputs.toolchain_version }}

      - name: Parse config and prepare packages
        id: prepare-packages
        run: |
          echo "Parsing config file..."
          
          # 创建包列表文件
          PACKAGE_LIST_FILE="${{ env.BUILD_STATUS_DIR }}/package_list.txt"
          > "$PACKAGE_LIST_FILE"
          
          # 用于跟踪已处理的包名（避免重复）
          declare -A PROCESSED_PACKAGES
          
          # 读取config文件
          while IFS='|' read -r ENABLED PACKAGE_NAME SOURCE_TYPE || [ -n "$ENABLED" ]; do
            # 跳过注释和空行
            [[ "$ENABLED" =~ ^#.*$ ]] && continue
            [[ -z "$ENABLED" ]] && continue
            [[ -z "$PACKAGE_NAME" ]] && continue
            
            # 跳过已处理的包（只编译第一个）
            if [ -n "${PROCESSED_PACKAGES[$PACKAGE_NAME]}" ]; then
              echo "Skipping duplicate package: $PACKAGE_NAME"
              continue
            fi
            
            # 检查是否启用编译
            if [ "$ENABLED" = "1" ]; then
              echo "Package enabled: $PACKAGE_NAME ($SOURCE_TYPE)"
              
              # 获取源码路径
              SOURCE_PATH=""
              if [ "$SOURCE_TYPE" = "file" ]; then
                SOURCE_PATH="packages/$PACKAGE_NAME"
              elif [ "$SOURCE_TYPE" = "repo" ]; then
                REPO_INFO=$(grep "^$PACKAGE_NAME|" repos | head -1)
                if [ -n "$REPO_INFO" ]; then
                  IFS='|' read -r NAME PROTOCOL REPO_URL BRANCH <<< "$REPO_INFO"
                  SOURCE_PATH="/tmp/source-$PACKAGE_NAME"
                  mkdir -p "$SOURCE_PATH"
                fi
              fi
              
              # 记录包信息
              echo "$PACKAGE_NAME|$SOURCE_TYPE|$SOURCE_PATH" >> "$PACKAGE_LIST_FILE"
              PROCESSED_PACKAGES[$PACKAGE_NAME]=1
            else
              echo "Package disabled: $PACKAGE_NAME"
            fi
          done < config
          
          # 输出包数量
          PACKAGE_COUNT=$(wc -l < "$PACKAGE_LIST_FILE")
          echo "Found $PACKAGE_COUNT packages to process"
          echo "package_count=$PACKAGE_COUNT" >> $GITHUB_OUTPUT

      - name: Process packages
        id: process-packages
        run: |
          PACKAGE_LIST_FILE="${{ env.BUILD_STATUS_DIR }}/package_list.txt"
          
          # 处理每个包
          while IFS='|' read -r PACKAGE_NAME SOURCE_TYPE SOURCE_PATH || [ -n "$PACKAGE_NAME" ]; do
            echo "Processing package: $PACKAGE_NAME"
            
            # 跳过强制清理的情况
            if [ "${{ github.event.inputs.clean_build }}" = "true" ] || [ "${{ github.event.inputs.skip_commit_check }}" = "true" ]; then
              echo "Forcing build for $PACKAGE_NAME (clean build or skip check)"
            else
              # 检查是否需要编译
              echo "Checking commit for $PACKAGE_NAME..."
              chmod +x scripts/check-commit.sh
              
              # 对于repo类型，先获取源码
              if [ "$SOURCE_TYPE" = "repo" ]; then
                REPO_INFO=$(grep "^$PACKAGE_NAME|" repos | head -1)
                IFS='|' read -r NAME PROTOCOL REPO_URL BRANCH <<< "$REPO_INFO"
                BRANCH="${BRANCH:-master}"
                
                # 克隆/检出代码
                mkdir -p "$SOURCE_PATH"
                case $PROTOCOL in
                  "git")
                    git clone --depth 1 --branch "$BRANCH" "$REPO_URL" "$SOURCE_PATH"
                    ;;
                  "svn")
                    svn checkout "$REPO_URL" "$SOURCE_PATH"
                    ;;
                  "hg")
                    hg clone -b "$BRANCH" "$REPO_URL" "$SOURCE_PATH"
                    ;;
                esac
              fi
              
              # 运行提交检查
              scripts/check-commit.sh "$PACKAGE_NAME" "$SOURCE_TYPE" "$SOURCE_PATH" "${{ env.COMMIT_LOG_DIR }}"
              
              # 如果跳过编译，创建标记文件
              if [ "$SKIP_COMPILE" = "true" ]; then
                echo "Marking $PACKAGE_NAME as skipped"
                touch "${{ env.BUILD_STATUS_DIR }}/${PACKAGE_NAME}_skip"
              fi
            fi
            
          done < "$PACKAGE_LIST_FILE"

      - name: Build packages
        id: build-packages
        continue-on-error: true  # 即使某些包失败也继续
        run: |
          PACKAGE_LIST_FILE="${{ env.BUILD_STATUS_DIR }}/package_list.txt"
          
          while IFS='|' read -r PACKAGE_NAME SOURCE_TYPE SOURCE_PATH || [ -n "$PACKAGE_NAME" ]; do
            echo "Building package: $PACKAGE_NAME"
            
            # 运行构建脚本
            chmod +x scripts/build-package.sh
            scripts/build-package.sh "$PACKAGE_NAME" "$SOURCE_TYPE" "$SOURCE_PATH" \
              "${{ env.COMMIT_LOG_DIR }}" "${{ env.BUILD_STATUS_DIR }}"
            
            # 更新状态
            if [ -f "${{ env.BUILD_STATUS_DIR }}/${PACKAGE_NAME}.status" ]; then
              STATUS=$(grep "^status=" "${{ env.BUILD_STATUS_DIR }}/${PACKAGE_NAME}.status" | cut -d= -f2)
              chmod +x scripts/update-status.sh
              scripts/update-status.sh "${{ env.BUILD_STATUS_DIR }}" "${{ env.COMMIT_LOG_DIR }}" \
                "$PACKAGE_NAME" "$LAST_COMMIT" "$STATUS"
            fi
            
            # 收集构建产物
            if [ "$STATUS" = "success" ] || [ "$STATUS" = "skipped" ]; then
              # 移动产物到artifacts目录
              mkdir -p "${{ env.ARTIFACT_DIR }}/latest/$PACKAGE_NAME"
              mkdir -p "${{ env.ARTIFACT_DIR }}/history/$PACKAGE_NAME/$(date +%Y%m%d_%H%M%S)"
              
              # 查找并复制产物
              BUILD_DIR="/tmp/build-$PACKAGE_NAME"*
              if [ -d "$BUILD_DIR/source" ]; then
                find "$BUILD_DIR/source" -type f \( -executable -o -name "*.apk" -o -name "*.ipk" -o -name "*.deb" -o -name "*.bin" \) \
                  ! -path "*/.*" -exec cp {} "${{ env.ARTIFACT_DIR }}/latest/$PACKAGE_NAME/" \; 2>/dev/null || true
                find "$BUILD_DIR/source" -type f \( -executable -o -name "*.apk" -o -name "*.ipk" -o -name "*.deb" -o -name "*.bin" \) \
                  ! -path "*/.*" -exec cp {} "${{ env.ARTIFACT_DIR }}/history/$PACKAGE_NAME/$(date +%Y%m%d_%H%M%S)/" \; 2>/dev/null || true
              fi
            fi
            
          done < "$PACKAGE_LIST_FILE"

      - name: Upload artifacts to outputs branch
        if: always()
        run: |
          echo "Uploading artifacts to outputs branch..."
          
          # 同步最新产物
          rsync -av --delete "${{ env.ARTIFACT_DIR }}/latest/" "outputs-branch/latest/"
          
          # 同步历史产物（不删除旧的历史）
          rsync -av "${{ env.ARTIFACT_DIR }}/history/" "outputs-branch/history/"
          
          # 同步提交记录
          rsync -av "${{ env.COMMIT_LOG_DIR }}/" "outputs-branch/${{ env.COMMIT_LOG_DIR }}/"
          
          # 同步构建状态（用于调试）
          rsync -av "${{ env.BUILD_STATUS_DIR }}/" "outputs-branch/${{ env.BUILD_STATUS_DIR }}/"
          
          # 创建索引文件
          cd outputs-branch
          cat > index.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
              <title>ImmortalWRT Compiled Packages</title>
              <style>
                  body { font-family: Arial, sans-serif; margin: 40px; }
                  .section { margin: 20px 0; padding: 20px; background: #f5f5f5; border-radius: 5px; }
                  .package { background: #e9e9e9; padding: 15px; margin: 10px 0; border-radius: 3px; }
                  .latest { border-left: 4px solid #4CAF50; }
                  .history { border-left: 4px solid #2196F3; }
              </style>
          </head>
          <body>
              <h1>ImmortalWRT Compiled Packages</h1>
              <p>Last updated: $(date)</p>
              <p>Build Run ID: ${{ github.run_id }}</p>
              
              <div class="section">
                  <h2>Latest Builds</h2>
          EOF
          
          # 添加最新构建列表
          for package in latest/*/; do
              if [ -d "$package" ]; then
                  PACKAGE_NAME=$(basename "$package")
                  echo "      <div class='package latest'>" >> index.html
                  echo "          <h3>$PACKAGE_NAME</h3>" >> index.html
                  echo "          <ul>" >> index.html
                  for file in "$package"*; do
                      if [ -f "$file" ]; then
                          FILENAME=$(basename "$file")
                          echo "              <li><a href='./latest/$PACKAGE_NAME/$FILENAME'>$FILENAME</a></li>" >> index.html
                      fi
                  done
                  echo "          </ul>" >> index.html
                  echo "      </div>" >> index.html
              fi
          done
          
          cat >> index.html << 'EOF'
              </div>
              
              <div class="section">
                  <h2>Build History</h2>
                  <p>Note: Historical builds are organized by date and package name.</p>
              </div>
              
              <div class="section">
                  <h2>Statistics</h2>
                  <p>Total packages configured: ${{ steps.prepare-packages.outputs.package_count }}</p>
                  <p><a href="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}">View this build on GitHub Actions</a></p>
              </div>
          </body>
          </html>
          EOF

      - name: Commit and push to outputs branch
        if: always()
        run: |
          cd outputs-branch
          
          # 配置Git
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # 添加所有文件
          git add .
          
          # 检查是否有更改
          if [ -n "$(git status --porcelain)" ]; then
              git commit -m "Update compiled packages - Run ${{ github.run_id }}"
              git push origin ${{ env.OUTPUTS_BRANCH }}
              echo "Changes pushed to ${{ env.OUTPUTS_BRANCH }} branch"
          else
              echo "No changes to commit"
          fi

      - name: Send Telegram notification
        if: always()
        run: |
          echo "Sending Telegram notification..."
          
          # 检查是否配置了Telegram密钥
          if [ -n "${{ secrets.TELEGRAM_BOT_TOKEN }}" ] && [ -n "${{ secrets.TELEGRAM_CHAT_ID }}" ]; then
              chmod +x scripts/send-telegram.sh
              
              # 确定工作流状态
              if [ "${{ job.status }}" = "success" ]; then
                  WORKFLOW_STATUS="success"
              else
                  WORKFLOW_STATUS="failure"
              fi
              
              scripts/send-telegram.sh \
                "${{ secrets.TELEGRAM_BOT_TOKEN }}" \
                "${{ secrets.TELEGRAM_CHAT_ID }}" \
                "${{ env.BUILD_STATUS_DIR }}" \
                "${{ github.repository }}" \
                "${{ github.run_id }}" \
                "$WORKFLOW_STATUS"
          else
              echo "Telegram credentials not configured. Skipping notification."
          fi

      - name: Upload build logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ github.run_id }}
          path: |
            ${{ env.BUILD_STATUS_DIR }}
            ${{ env.COMMIT_LOG_DIR }}
          retention-days: 30
